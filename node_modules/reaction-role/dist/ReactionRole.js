"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReactionRole = void 0;
const logger_1 = require("@hammerhq/logger");
const bookman_1 = require("bookman");
const discord_js_1 = require("discord.js");
const lodash_1 = require("lodash");
const types_1 = require("./types");
const utils_1 = require("./utils");
class ReactionRole extends discord_js_1.Client {
    constructor({ token, db_config, logging }) {
        super({
            intents: [
                "GuildEmojisAndStickers",
                "GuildMembers",
                "GuildMessageReactions",
                "GuildMessages",
                "Guilds",
            ],
        });
        this.logger = new logger_1.Logger("[ReactionRole]:");
        this.ready = false;
        this.config = {};
        this.createOption = (clickable) => clickable;
        this.exportConfig = () => this.config;
        const cfg = (0, lodash_1.merge)(types_1.default_db_config || {}, db_config);
        this._token = token;
        this.logging = logging || false;
        this.database = new bookman_1.Database(cfg);
        this._db_config = cfg;
        this.on_get = () => this.database.get(cfg.prefix);
        this.on_delete = (message_id) => this.database.delete(`${cfg.prefix}.${message_id}`);
        this.on_set = (new_data) => this.database.set(cfg.prefix, new_data);
    }
    onGet(on_get) {
        this.on_get = on_get;
        return this;
    }
    onSet(on_set) {
        this.on_set = on_set;
        return this;
    }
    onDelete(on_delete) {
        this.on_delete = on_delete;
        return this;
    }
    createMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const clone = Object.assign({}, message);
            for (const clickable of message.clickables) {
                if (clickable.onClick)
                    clickable.onClick = (0, utils_1.stringifyFunction)(clickable.onClick);
                if (clickable.onRemove)
                    clickable.onRemove = (0, utils_1.stringifyFunction)(clickable.onRemove);
            }
            (0, lodash_1.set)(this.config, message.message_id, message);
            if (this.on_set)
                yield this.on_set(this.config);
            return clone;
        });
    }
    deleteMessage(message_id) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, lodash_1.unset)(this.config, message_id);
            if (this.on_delete)
                yield this.on_delete(message_id);
            return this.config;
        });
    }
    importConfig(config) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, lodash_1.merge)(this.config, config);
            if (this.on_get) {
                const saved = (yield this.on_get()) || {};
                (0, lodash_1.merge)(saved, this.config);
                if (this.on_set)
                    yield this.on_set(saved);
            }
            return this.config;
        });
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            const now = Date.now();
            if (this.logging)
                this.logger.event("Spawning ReactionRole...");
            this.on("ready", () => __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                if (this.logging)
                    this.logger.info(`Logged in as ${(_a = this.user) === null || _a === void 0 ? void 0 : _a.tag}!`);
                if (this.on_get) {
                    this.logger.event("Loading data from database.");
                    const saved = (yield this.on_get());
                    if (saved) {
                        this.logger.info(`Importing ${Object.keys(saved).length} messages...`);
                        this.importConfig(saved);
                        this.logger.success(`Successfully imported ${Object.keys(saved).length} messages!`);
                    }
                    else
                        this.logger.warning("Database is empty.");
                }
                if (this.logging) {
                    this.logger.event("Fetching messages.");
                    this.logger.info(`Fetching ${Object.keys(this.config).length} messages...`);
                }
                for (const message_id in this.config) {
                    const message = this.config[message_id];
                    const channel = (yield this.channels
                        .fetch(message.channel_id)
                        .catch(() => undefined));
                    if (!channel || channel.type != discord_js_1.ChannelType.GuildText) {
                        this.deleteMessage(message.message_id);
                        continue;
                    }
                    new Function();
                    const msg = yield channel.messages
                        .fetch(message.message_id)
                        .catch(() => undefined);
                    if (!msg) {
                        this.deleteMessage(message.message_id);
                        continue;
                    }
                    for (const clickable of message.clickables) {
                        if (!msg.reactions.cache.has(clickable.clickable_id) ||
                            !((_b = msg.reactions.cache
                                .get(clickable.clickable_id)) === null || _b === void 0 ? void 0 : _b.users.cache.has((_c = this.user) === null || _c === void 0 ? void 0 : _c.id)))
                            yield msg.react(clickable.clickable_id);
                    }
                }
                if (this.logging)
                    this.logger.success(`Successfully fetched ${Object.keys(this.config).length} messages!`);
                this.ready = true;
                const then = Date.now();
                if (this.logging)
                    this.logger.success("Ready ðŸš€! Took", then - now, "ms");
            }));
            this.on("messageReactionAdd", (reaction, user) => __awaiter(this, void 0, void 0, function* () {
                var _d;
                if (!this.ready)
                    return;
                if (reaction.partial)
                    reaction = yield reaction.fetch();
                if (!reaction.message.guild)
                    return;
                if (user.partial)
                    user = yield user.fetch();
                if (!reaction.message.guild.members.cache.has(user.id))
                    return;
                if (!(0, lodash_1.has)(this.config, reaction.message.id))
                    return;
                const message = (0, lodash_1.get)(this.config, reaction.message.id);
                const clickable = message.clickables.find((clickable) => clickable.clickable_id ==
                    (reaction.emoji.id || reaction.emoji.name));
                if (!clickable)
                    return;
                const member = (_d = reaction.message.guild) === null || _d === void 0 ? void 0 : _d.members.cache.get(user.id);
                if (message.limit && message.limit > 0) {
                    const reactions = reaction.message.reactions.cache.filter((r) => message.clickables.some((clickable) => clickable.clickable_id ==
                        (r.emoji.id || r.emoji.name)) && r.users.cache.has(user.id));
                    if (reactions.size > message.limit) {
                        yield reaction.users.remove(user.id);
                        return;
                    }
                }
                const roles = clickable.roles.filter((id) => clickable.type == types_1.EType.REMOVE
                    ? member.roles.cache.has(id)
                    : !member.roles.cache.has(id));
                if (roles.length < 1)
                    return;
                switch (clickable.type) {
                    case types_1.EType.NORMAL:
                        yield member.roles.add(roles);
                        break;
                    case types_1.EType.ONCE:
                        yield member.roles.add(roles);
                        yield reaction.users.remove(member.id);
                        break;
                    case types_1.EType.REMOVE:
                        yield member.roles.remove(roles);
                        break;
                    case types_1.EType.CUSTOM:
                        yield member.roles.add(roles);
                        if (clickable.onClick) {
                            const fn = (0, utils_1.parseFunction)(clickable.onClick);
                            fn(clickable, member);
                        }
                }
                if (clickable.add_message)
                    yield member.send(clickable.add_message).catch(() => undefined);
            }));
            this.on("messageReactionRemove", (reaction, user) => __awaiter(this, void 0, void 0, function* () {
                var _e;
                if (!this.ready)
                    return;
                if (reaction.partial)
                    reaction = yield reaction.fetch();
                if (!reaction.message.guild)
                    return;
                if (user.partial)
                    user = yield user.fetch();
                if (!reaction.message.guild.members.cache.has(user.id))
                    return;
                if (!(0, lodash_1.has)(this.config, reaction.message.id))
                    return;
                const message = (0, lodash_1.get)(this.config, reaction.message.id);
                const clickable = message.clickables.find((clickable) => clickable.clickable_id ==
                    (reaction.emoji.id || reaction.emoji.name));
                if (!clickable)
                    return;
                // iÅŸlem iptal ediliyor Ã§Ã¼nkÃ¼ ONCE tÃ¼rÃ¼ndeki clickable componentlerde reaction otomatik olarak kaldÄ±rÄ±lÄ±yor.
                // bu yÃ¼zden reaction remove eventi tetikleniyor ve rolÃ¼n tekrar kaldÄ±rÄ±lmamasÄ± gerekiyor.
                if (clickable.type == types_1.EType.ONCE)
                    return;
                const member = (_e = reaction.message.guild) === null || _e === void 0 ? void 0 : _e.members.cache.get(user.id);
                const roles = clickable.roles.filter((id) => clickable.type == types_1.EType.REMOVE
                    ? !member.roles.cache.has(id)
                    : member.roles.cache.has(id));
                if (roles.length < 1)
                    return;
                switch (clickable.type) {
                    case types_1.EType.NORMAL:
                        yield member.roles.remove(roles);
                        break;
                    case types_1.EType.REMOVE:
                        yield member.roles.add(roles);
                        break;
                    case types_1.EType.CUSTOM:
                        yield member.roles.remove(roles);
                        if (clickable.onRemove) {
                            const fn = (0, utils_1.parseFunction)(clickable.onRemove);
                            fn(clickable, member);
                        }
                }
                if (clickable.remove_message)
                    yield member
                        .send(clickable.remove_message)
                        .catch(() => undefined);
            }));
            const token = yield this.login(this._token);
            if (this.logging)
                this.logger.success("ReactionRole spawned successfully!");
            return token;
        });
    }
    reInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.destroy();
            const rr = new ReactionRole({
                token: this._token,
                db_config: this._db_config,
                logging: this.logging,
            });
            yield rr.importConfig(this.config);
            return rr;
        });
    }
}
exports.ReactionRole = ReactionRole;
